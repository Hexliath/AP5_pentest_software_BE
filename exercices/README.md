# Exercices instructions


## Setup

- Download and create a 64-bit linux based VM (debian is preferred) 
- Install gdb-peda 
- Install python3
- Install pwntools (using pip3 or pip)


## Compilation


```bash
gcc -g -fno-stack-protector -z execstack -mpreferred-stack-boundary=2 -m32  <exercise.c>  -o <exercice> 
```

### Explanations
 
- -m32: compile as a x32 binary
- -fno-stack-protector: Disable the stack exploitation mechanisms.
- -z execstack: The stack is executable  
- -mpreferred-stack-boundary=2: Align the stack 4-bytes

## Exercises

Homework: Please create an unique markdown report and export it to pdf. 

### Exercise 1: Simple redirection

The goal is to get a bash shell.   
You will need to control EIP and redirect the execution flow to the shell() function.

#### Reporting requirements
- Crash screenshot
- Controlling the offset
- EIP = shell() address
- Whoami command on your popped shell.


### Exercice 2: Fuzzing is the key

Make the program crash. Try to figure it out which function is a potential vulnerability.

#### Reporting requirements
- Boofuzz script
- Application segfault.


### Exercice 3: Is there another way ?

Using Ghidra, decompile the program and explain the vulnerability.  
By the way, find the hidden functionnality.

#### Reporting requirements
- Ghidra is running and the program is decompiled
- Explain the vulnerability using the ASM code
- What is the hidden functionnality ? what is its purpose?



### Exercise 4: Jumping to your shellcode

Using the result you found in the second exercice you can now execute an injected payload of your choice.

Oh no wait, this shellcode :
http://shell-storm.org/shellcode/files/shellcode-833.php
(youâ€™ll we have to update your IP !)


#### Reporting requirements
- Crash screenshot
- Controlling the offset
- Find a "jmp esp"
- Jumping to a nop-slide
- Jumping to your shellcode
- The reverse shell appears
- Your exploit.py script





